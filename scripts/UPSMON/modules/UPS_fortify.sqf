MON_Bld_remove = ["Bridge_PathLod_base_F","Land_Slum_House03_F","Land_Bridge_01_PathLod_F","Land_Bridge_Asphalt_PathLod_F","Land_Bridge_Concrete_PathLod_F","Land_Bridge_HighWay_PathLod_F","Land_Bridge_01_F","Land_Bridge_Asphalt_F","Land_Bridge_Concrete_F","Land_Bridge_HighWay_F","Land_Canal_Wall_Stairs_F"];MON_Bld_ruins = ["Land_Unfinished_Building_01_F","Land_Unfinished_Building_02_F","Land_d_Stone_HouseBig_V1_F","Land_d_Stone_Shed_V1_F","Land_u_House_Small_02_V1_F","Land_i_Stone_HouseBig_V1_F","Land_u_Addon_02_V1_F"];//Función que retorna array de arrays con edificios y sus plantas//Parámeters: [_object,(_distance,_minfloors)]//	<-	_object: soldier to get near buildings //	<-	_distance: distance to search buildings (optional, 25 by default)//	<- 	_minfloors:  min floors of building (optional) if not especified  min floors is 2// 	->	 [_bld,_bldpos] MON_GetNearestBuildings = {	private ["_object","_altura","_pos","_bld","_bldpos","_posinfo","_minfloors","_OCercanos","_distance","_blds","_bldpositions"];	_distance = 25;	_minfloors = 3;	_altura = 0;	_blds = [];	_object = _this select 0;	if ((count _this) > 1) then {_distance = _this select 1;};	if ((count _this) > 2) then {_minfloors = _this select 2;};	 	_pos =0;	_bld = objnull;	_bldpositions = [];	_posinfo=[];	//La altura mínima es 2 porque hay muchos edificios q devuelven 2 de altura pero no se puede entrar en ellos.	if ( _minfloors == 0  ) then {		_minfloors = 3;	 };			// _posinfo: [0,0]=no house near, [obj,0]=house near, but no roof positions, [obj,pos]=house near, with roof pos	//_posinfo= _object call MON_PosInfo;											_OCercanos = nearestObjects [_object, ["house","building"] , _distance];			{		If (!((typeof _x) in MON_Bld_remove)) then {		_bldpos = [_x, 20] call BIS_fnc_buildingPositions;		sleep 0.2;		_allpos = [_x,_bldpos] call Aze_SortOutBldpos; 		if ( count _allpos >= _minfloors && damage _x <= 0 ) then { _bldpositions = _bldpositions + [[_x,_allpos]];};		//player sidechat format["%1 cerca de edificio con %2 plantas %5",typeof _object,_bldpos];		};	}foreach _OCercanos;			_bldpositions;};//Function to move al units of squad to near buildings//Parámeters: [_npc,(_patrol,_minfloors)]//	<-	 _npc: lider//	<-	 _distance: distance to search buildings (optional, 25 by default)//	<-	 _patrol: wheter must patrol or notMON_moveNearestBuildings = {	private ["_npc","_altura","_pos","_bld","_bldpos","_posinfo","_blds","_distance","_cntobjs1","_bldunitin","_blddist","_patrol","_wait","_all"];	_distance = 30;	_altura = 0;	_patrol = false;		_wait=60;	_all = false;		_npc = _this select 0;	if ((count _this) > 1) then {_distance = _this select 1;};	if ((count _this) > 2) then {_patrol = _this select 2;};	if ((count _this) > 3) then {_wait = _this select 3;};	if ((count _this) > 4) then {_all = _this select 4;}; 	_pos =0;	_bld = objnull;	_bldpos =[];	_cntobjs1=0;	_bldunitsin=[];	_units=[];	_blds=[];		//If all soldiers move leader too	if (_all) then {		_units = (units _npc);	}else{		_units = (units _npc) - [_npc];	}; 		sleep 0.05;	{		if (_x iskindof "Man" && unitReady _x && _x == vehicle _x && canmove _x && alive _x && canstand _x) then {_bldunitsin = _bldunitsin + [_x]}	}foreach _units;		if (count _bldunitsin == 0) exitwith {};				//Obtenemos los edificios cercanos al lider	_blds = [_npc,_distance] call MON_GetNearestBuildings;				if (count _blds==0) exitwith {};		//Movemos a la unidades a los edificios cercanos.	[_bldunitsin, _blds, _patrol,_wait,_all] spawn MON_moveBuildings;	};//Function to move al units of squad to near buildings//Parámeters: [_npc,(_patrol,_minfloors)]//	<-	 _units: array of units//	<-	 _blds: array of buildingsinfo [_bld,pos]//	<-	 _patrol: wheter must patrol or not//	->	_bldunitsin: array of units moved to builidingsMON_moveBuildings = {	private ["_npc","_altura","_pos","_bld","_bldpos","_posinfo","_blds","_cntobjs1","_bldunitin","_blddist","_i","_patrol","_wait","_all","_minpos","_blds2"];	_patrol = false;	_wait = 60;	_minpos  = 2;	_all = false;	_units = _this select 0;	_blds = _this select 1;	if ((count _this) > 2) then {_patrol = _this select 2;};	if ((count _this) > 3) then {_wait = _this select 3;};	if ((count _this) > 4) then {_all = _this select 4;};	if ((count _this) > 5) then {_minpos = _this select 5;};		_altura = 0;	_pos =0;	_bld = objnull;	_bldpos =[];	_cntobjs1=0;	_bldunitsin=[];	_movein=[];	_blds2 =[];	//if (KRON_UPS_Debug>0) then {player globalchat format["MON_moveBuildings _units=%1 _blds=%2",count _units, count _blds];	};		//if (KRON_UPS_Debug>0) then {diag_log format["MON_moveBuildings _units=%1 _blds=%2",count _units, count _blds];};		(group (_units select 0)) setSpeedmode "FULL";	{		_bld 		= _x select 0;		_bldpos 	= _x select 1; 				if ( count _bldpos >= _minpos ) then {			_cntobjs1 = 2;					_movein = [];			_i = 0;								if (_patrol) then {				if (count _bldpos >= 8) then {_cntobjs1 =  4};			} else {					if (count _bldpos >= 8) then { _cntobjs1 =   round(random 3)  + 4;};							};										//Buscamos una unidad cercana para recorrerlo			{											if (_x iskindof "Man" && unitReady _x && canmove _x && alive _x && vehicle _x == _x && _i < _cntobjs1) then{					_movein = _movein + [_x];					_i = _i + 1;										};			} foreach  _units;								//if (KRON_UPS_Debug>0) then {player globalchat format["_units=%3 _bldunitsin %4 _movein=%1",_movein, typeof _bld, count _units, count _bldunitsin];}			//if (KRON_UPS_Debug>0) then {diag_log format["_units=%3 _bldunitsin %4 _movein=%1 %2 %5",_movein, typeof _bld, count _units, count _bldunitsin,_x];};										if (count _movein > 0) then {				_bldunitsin = _bldunitsin + _movein;					_units = _units - _bldunitsin;									if (_patrol) then {					{						[_x,_bld,_bldpos] spawn MON_patrolBuilding;						}foreach _movein;				} else {										{						If (1 in _bldpos) then {_bldpos = _bldpos - [1];};						_altura = _bldpos select 0;						[_x,_bld,_altura,_wait] spawn MON_movetoBuilding;						_bldpos set [0,1];						_bldpos = _bldpos - [0];						sleep 0.3;						_bldpos = _bldpos - [1];						}foreach _movein;				};											};			};		If (!(typeof _bld in MON_Bld_ruins)) then {		[_bld] execvm "Scripts\UPSMON\Aze\Aze_CloseDoor.sqf";};		if (count _units == 0) exitwith {};	}foreach _blds;			//If need to enter all units in building and rest try with a superior lvl	if ( _all && count _units > 0 ) then {		_blds2 = [];		_minpos = _minpos;		{			if ( count (_x select 1) >= _minpos) then {				_blds2 = _blds2 + [_x];			};		}foreach _blds;				//if (KRON_UPS_Debug>0) then {player globalchat format["MON_moveBuildings exit _units=%1 _blds=%2",count _units, count _blds2];	};			//if (KRON_UPS_Debug>0) then {diag_log format["MON_moveBuildings exit _units=%1 _blds=%2",count _units, count _blds2];};							if (count _blds2 > 0 ) then {			[_units, _blds2, _patrol,_wait,_all,_minpos] spawn MON_moveBuildings;			};		_bldunitsin = _bldunitsin + _units;	};	sleep 10;	(group (_units select 0)) setSpeedmode "LIMITED";};//Function to move a unit to a position in a building//Parámeters: [_npc,(_patrol,_minfloors)]//	<-	 _npc: soldier//	<-	 _bld: building//	<-	 _altura: building//	<-	 _wait: time to wait in positionMON_movetoBuilding = {	private ["_npc","_altura","_bld","_wait","_dist","_retry","_soldiers"];	_wait = 60; // 60	_timeout = 180; // 120	_dist = 0;	_retry = false;				_npc = _this select 0;	_bld = _this select 1;	_altura = _this select 2;		if ((count _this) > 3) then {_wait = _this select 3;};	//Si está en un vehiculo ignoramos la orden	if (vehicle _npc != _npc || !alive _npc || !canmove _npc) exitwith{};		//Si ya está en un edificio ignoramos la orden	_inbuilding = _npc getvariable ("UPSMON_inbuilding");	if ( isNil("_inbuilding") ) then {_inbuilding = false;};		if (_inbuilding)  exitwith{};		diag_log format["%4|_bld=%1 | %2 | %3",typeof _bld, _npc, typeof _npc ,_altura];	_oldposnpc = getpos _npc;	_npc domove _altura; 		_npc setVariable ["UPSMON_inbuilding", _inbuilding, false];			_npc setvariable ["UPSMON_buildingpos", nil, false];		sleep 5;	If (_oldposnpc distance (getpos _npc) < 1) then {_npc domove _altura; _npc forcespeed 1;};	_timeout = time + _timeout;	if (KRON_UPS_Debug>0) then {player globalchat format["%4|_bld=%1 | %2 | %3",typeof _bld, _npc, typeof _npc ,_altura];};		//if (KRON_UPS_Debug>0) then {diag_log format["%4|_bld=%1 | %2 | %3",typeof _bld, _npc, typeof _npc ,_altura];};		waitUntil {(_npc distance _altura <= 1) || !alive _npc || !canmove _npc || _timeout < time};		if ((_npc distance _altura <= 1) && alive _npc && canmove _npc) then {					//_dist = [position _npc,_bld buildingPos _altura] call KRON_distancePosSqr;				_soldiers = [_npc,0.5] call MON_nearestSoldiers;								//If more soldiers in same floor see to keep or goout.		if (count _soldiers > 0) then {								{				if (!isnil{_x getvariable ("UPSMON_buildingpos")}) exitwith {_retry = true};											}foreach _soldiers;						};							if (!_retry) then {			_npc setvariable ["UPSMON_buildingpos", _altura, false];				sleep 0.1;			[_npc,_wait] spawn MON_dostop;			sleep 2;			[_npc,getdir _npc,_bld] call Aze_UnitWatchDir;			sleep 4;			if (!isNil "tpwcas_running") then {_npc setvariable ["tpwcas_cover", 2];};		};		};		if (!alive _npc || !canmove _npc) exitwith{};		_npc setVariable ["UPSMON_inbuilding", false, false];						//Down one position.	if (_retry ) then {				_bldpos = [_bld, 20] call BIS_fnc_buildingPositions;		sleep 0.5;		_allpos = [_bld,_bldpos] call Aze_SortOutBldpos;		sleep 0.5;		_nbr = floor (random (count _bldpos));		If (_nbr >= count _bldpos) then {_nbr = _nbr - 1;};		_altura = _bldpos select _nbr;		// diag_log format["%4|_bld=%1 | %2 | %3 | retry: %4",typeof _bld, _npc, typeof _npc ,_altura,_retry];				[_npc,_bld,_altura] spawn MON_movetoBuilding;			};};//Función para mover a una unidad al edificio más cercano//Parámeters: [_npc,_bld,(_BldPos)]//	<-	 _npc: soldier to move// 	<-	 _bld:building to patrol//	<-	 _BldPos: positions of builiding (optional)MON_patrolBuilding = {	private ["_npc","_bld","_bldpos","_posinfo","_minfloors","_OCercanos","_distance","_timeout","_pos","_inbuilding","_rnd","_NearestEnemy","_patrolto","_time"];	_bldpos = 0;	_pos = 0;	_timeout = 0;	_i = 1;	_inbuilding = false;	_rnd = 0;	_patrolto = 0;	_NearestEnemy = objnull;	_time = 0;	_npc = _this select 0;	_bld = _this select 1;	if ((count _this) > 2) then {_bldpos = _this select 2;}; 			if (_i > count _bldpos) then {_i = count _bldpos};	_patrolto = round ( 4 + random (count _bldpos) );		//if (_patrolto > _bldpos) then {_patrolto = _bldpos};		//Si ya está  muerto o no se puede mover se ignora	if (!(_npc iskindof "Man") || !alive _npc || !canmove _npc) exitwith{};		//Si ya está en un edificio ignoramos la orden	_inbuilding = _npc getvariable ("UPSMON_inbuilding");	if ( isNil("_inbuilding") ) then {_inbuilding = false;};			//Asignamos el vehiculo a a la escuadra si contiene las posiciones justas	if (!_inbuilding) then {		_inbuilding	 = true;		_npc setVariable ["UPSMON_inbuilding", _inbuilding, false];			[_npc,"Auto"] spawn MON_setUnitPos;		_timeout = time + 20;				//player sidechat format["%1 patrol building %2 from %3 to %4",typeof _npc, typeof _bld,_i, _patrolto];									while { _i <= _patrolto && alive _npc && canmove _npc} do{			_npc domove (_bldpos select _i); 												_time = time + 30;						waitUntil {(_npc distance (_bldpos select _i) <= 1) || moveToFailed _npc || !alive _npc || _time < time};						if ((_npc distance (_bldpos select _i) <= 1)) then {				_timeout = time + 20;				_i = _i + 1;			} else {				if (moveToFailed _npc  || !canmove _npc || !alive _npc || _timeout < time) then {					//player sidechat format["%1 Cancelando patrulla en %2",_npc, typeof _bld];										_i = _patrolto + 1;				};					};						sleep 0.05;		};				//Si está en un vehiculo ignoramos la orden		if (!alive _npc || !canmove _npc) exitwith{};				//Volvemos con el lider		_npc domove	(position leader _npc);				//Marcamos que ya hemos finalizado		sleep 60; //Damos tiempo para salir del edificio		_npc setVariable ["UPSMON_inbuilding", false, false];				};		};Aze_UnitWatchDir = {	private ["_see","_infront","_uposASL","_opp","_adj","_hyp","_eyes","_obstruction","_angle","_inbuilding"];		_unit = _this select 0;	_angle = _this select 1;	_bld = _this select 2;	_essai = 0;	_see = false;	_ouverture = false;	_findoor = false;	_inbuilding = [_unit] call Aze_inbuilding;		If (!_inbuilding) then {			// check window		_windowposition = [_bld] call Aze_checkwindowposition;		sleep 0.4;		_watch = [];		If (count _windowposition > 0) then 		{			{				_x = [_x select 0,_x select 1,(getPosATL _unit) select 2];				If ((_unit distance _x) <= 3) exitwith {_watch = _x;};			} forEach _windowposition;				if (count _watch > 0) then 			{						_posATL = getPosATL _unit;				_abx = (_watch select 0) - (_posATL select 0);				_aby = (_watch select 1) - (_posATL select 1);				_abz = (_watch select 2) - (_posATL select 2);				_vec = [_abx, _aby, _abz];				// Main body of the function;				_unit setVectorDir _vec;								sleep 0.2;				_unit lookat ObjNull;				_unit lookat _watch;				_ouverture = true;										// _ballCover = "Sign_Arrow_Large_Blue_F" createvehicle [0,0,0];				// _ballCover setpos _watch;				};		}; 		// If no window found check for door		If (!_ouverture) then		{			_doorposition = [_bld] call Aze_checkdoorposition;			sleep 0.4;			_watch = [];						If (count _doorposition > 0) then 		{			{				_x = [_x select 0,_x select 1,(getPosATL _unit) select 2];				If ((_unit distance _x) <= 5) exitwith {_watch = _x;};			} forEach _doorposition;				if (count _watch > 0) then 			{				_posATL = getPosATL _unit;				_abx = (_watch select 0) - (_posATL select 0);				_aby = (_watch select 1) - (_posATL select 1);				_abz = (_watch select 2) - (_posATL select 2);				_vec = [_abx, _aby, _abz];				// Main body of the function;				_unit setVectorDir _vec;					sleep 0.2;				_unit lookat ObjNull;				_unit lookat _watch;								// _ballCover = "Sign_Arrow_Large_RED_F" createvehicle [0,0,0];				// _ballCover setpos _watch;					_ouverture = true;				_findoor = true;			};		};		};	};	Sleep 2;	// Check if window not blocking view or search direction for AI if he doesn't watch window or door.	If (!(_findoor)) then 	{		_cansee = [_unit,getdir _unit,_bld] spawn Aze_WillSee;	};	};Aze_checkdoorposition = {	private [];	_house = _this select 0;	_anim_source_pos_arr = [];		_cfgUserActions = (configFile >> "cfgVehicles" >> (typeOf _house) >> "UserActions");	for "_i" from 0 to count _cfgUserActions - 1 do 	{		_cfg_entry = _cfgUserActions select _i;    		if (isClass _cfg_entry) then		{			_display_name = getText (_cfg_entry / "displayname");			if (_display_name == "Open hatch" or {_display_name == "Open door"}) then			{				_selection_name = getText (_cfg_entry / "position");				_model_pos = _house selectionPosition _selection_name;				_world_pos = _house modelToWorld _model_pos;				_anim_source_pos_arr = _anim_source_pos_arr + [_world_pos];			};		};	};	_anim_source_pos_arr};Aze_checkwindowposition = {	private ["_model_pos","_world_pos","_armor","_cfg_entry","_veh","_house","_window_pos_arr","_cfgHitPoints","_cfgDestEff","_brokenGlass","_selection_name"];	_house = _this select 0;	_window_pos_arr = [];	_cfgHitPoints = (configFile >> "cfgVehicles" >> (typeOf _house) >> "HitPoints");	for "_i" from 0 to count _cfgHitPoints - 1 do 	{		_cfg_entry = _cfgHitPoints select _i;    		if (isClass _cfg_entry) then		{			_armor = getNumber (_cfg_entry / "armor");			if (_armor < 0.5) then			{				_cfgDestEff = (_cfg_entry / "DestructionEffects");				_brokenGlass = _cfgDestEff select 0;				_selection_name = getText (_brokenGlass / "position");				_model_pos = _house selectionPosition _selection_name;				_world_pos = _house modelToWorld _model_pos;				_window_pos_arr = _window_pos_arr + [_world_pos];			};		};	}; 		_window_pos_arr};Aze_WillSee = {// garrison func from ....	private ["_see","_infront","_opp","_adj","_hyp","_eyes","_obstruction","_angle"];	_unit = _this select 0;	_angle = _this select 1;	_bld = _this select 2;	_essai = 0;	If (count _this > 3) then {_essai = _this select 3;};	_eyes = eyepos _unit;	_hyp = 10;	_adj = _hyp * (cos _angle);	_opp = sqrt ((_hyp*_hyp) - (_adj * _adj));		_infront = if ((_angle) >=  180) then 	{		[(_eyes select 0) - _opp,(_eyes select 1) + _adj,(_eyes select 2)]	} 	else 	{		[(_eyes select 0) + _opp,(_eyes select 1) + _adj,(_eyes select 2)]	};	_obstruction = (lineintersectswith [_eyes,_infront,_unit]) select 0;	_see = if (isnil("_obstruction")) then {true} else {false};	If (!_see && _essai < 15) exitwith 	{		_essai = _essai + 1;		_angle = random 360;		[_unit,_angle,_bld,_essai] call Aze_WillSee;	};	If (_see) then 	{		_posATL = getPosATL _unit;		_abx = (_infront select 0) - (_posATL select 0);		_aby = (_infront select 1) - (_posATL select 1);		_abz = (_infront select 2) - (_posATL select 2);		_vec = [_abx, _aby, _abz];		// Main body of the function;		_unit setVectorDir _vec;		sleep 0.02;		_unit lookat ObjNull;		_unit lookat [_infront select 0,_infront select 1, 1];				// _ballCover = "Sign_Arrow_Large_GREEN_F" createvehicle [0,0,0];		// _ballCover setpos [_infront select 0,_infront select 1, 1];	};};Aze_Inbuilding = {private ["_Inbuilding","_posunit","_unit","_abovehead","_roof"];	_unit = _this select 0;	_posunit = [(getposASL _unit) select 0,(getposASL _unit) select 1,((getposASL _unit) select 2) + 0.5];	_abovehead = [_posunit select 0,_posunit select 1,(_posunit select 2) + 20];	_roof = (lineintersectswith [_posunit,_abovehead,_unit]) select 0;	_Inbuilding = if (isnil("roof")) then {false} else {true};_Inbuilding};Aze_SortOutBldpos = {	private ["_bld","_bldpos","_windowspos","_doorspos","_otherspos","_windowsposition","_doorsposition"];	_bld = _this select 0;	_bldpos = _this select 1;	_windowspos = [];	_doorspos = [];	_otherspos = [];	_allpos = [];	_roofspos = [];	if (!(typeof _bld in MON_Bld_ruins)) then {	_windowsposition = [_bld] call Aze_checkwindowposition;	_doorsposition = [_bld] call Aze_checkdoorposition;};		sleep 0.1;	{		_bldpos1 = _x;		_loop = true;		if (!(typeof _bld in MON_Bld_ruins)) then 		{			If (count _windowsposition > 0) then 			{				{					_windowpos1 = _x;					If (_bldpos1 distance _windowpos1 <= 2) then {_windowspos = _windowspos + [_bldpos1]; _loop = false;};				} foreach _windowsposition;			};			If (count _doorsposition > 0 && _loop) then 			{				{					_doorpos1 = _x;					If (_bldpos1 distance _doorpos1 <= 2) then {_doorspos = _doorspos + [_bldpos1]; _loop = false;};							} foreach _doorsposition;					};		} 		else 		{			_pos1 = _bldpos1 select 2;			If (_pos1 >= 3) then {_roofspos = _roofspos + [_bldpos1]; _loop = false;};		};						If (_loop) then {		_otherspos = _otherspos + [_bldpos1];		};		sleep 0.2;		} foreach _bldpos;		//	if (count _windowspos > 0) then {//	{//	_ballCover = "Sign_Arrow_Large_BLUE_F" createvehicle [0,0,0];// 	_ballCover setpos _x;	//	} foreach _windowspos;//	};	//	if (count _doorspos > 0) then {//	{//	_ballCover = "Sign_Arrow_Large_RED_F" createvehicle [0,0,0];// 	_ballCover setpos _x;	//	} foreach _doorspos;//	};	//	if (count _otherspos > 0) then {//	{//	_ballCover = "Sign_Arrow_Large_GREEN_F" createvehicle [0,0,0];//	_ballCover setpos _x;	//	} foreach _otherspos;//	};		if (count _windowspos > 0) then 	{		_windowspos call BIS_fnc_arrayShuffle;		sleep 0.1;		_allpos = _allpos + _windowspos;	};		if (count _doorspos > 0) then 	{		_doorspos call BIS_fnc_arrayShuffle;		sleep 0.1;		_allpos = _allpos + _doorspos;	};		if (count _roofspos > 0) then 	{		_roofspos call BIS_fnc_arrayShuffle;		sleep 0.1;		_allpos = _allpos + _roofspos;	};		if (count _otherspos > 0) then 	{		_otherspos call BIS_fnc_arrayShuffle;		sleep 0.1;		_allpos = _allpos + _otherspos;	};			// if (isNil (_bld getvariable "Aze_bldPos")) then {_bld setvariable ["Aze_bldPos",_allpos];};		_allpos};